_		 = require 'underscore'
async = require 'async'
fs		= require 'fs'

{extname, join, normalize} = require 'path'

exports.compilers = compilers =
	js: (module, filename) ->
		content = fs.readFileSync filename, 'utf8'
		module._compile content, filename

try
	CoffeeScript = require 'coffee-script'
	compilers.coffee = (module, filename) ->
		content = CoffeeScript.compile fs.readFileSync filename, 'utf8'
		module._compile content, filename
catch err

try
	LiveScript = require 'LiveScript'
	compilers.ls = (module, filename) ->
		content = LiveScript.compile ( fs.readFileSync filename, 'utf8' ), {prelude: true}
		module._compile content, filename
catch err

try
	{exec} = require "child_process"
	execSync = require "exec-sync"
	compilers.ts = (module, filename) ->
		newfile = filename.substr(0, filename.lastIndexOf(".")) + ".js"
		child = execSync "tsc #{filename}"
		content = fs.readFileSync "#{newfile}", 'utf8'
		fs.unlink newfile
		module._compile content, filename
catch err

try
	compilers.html = compilers.html = (module, filename) ->
		content = fs.readFileSync filename, "utf8"
		content = content.replace /\\?"/g, "\\\""
		content = content.replace /\r?\n/g, "\\n"
		module._compile "module.exports = \"#{content}\"", filename
catch err

try
	md = ( require "node-markdown" ).Markdown
	compilers.md = compilers.markdown = (module, filename) ->
		content = md fs.readFileSync filename, "utf8"
		content = content.replace /\\?"/g, "\\\""
		content = content.replace /\r?\n/g, "\\n"
		module._compile "module.exports = \"#{content}\"", filename
catch err

try
	eco = require 'eco'
	if eco.precompile
		compilers.eco = (module, filename) ->
			content = eco.precompile fs.readFileSync filename, 'utf8'
			module._compile "module.exports = #{content}", filename
	else
		compilers.eco = (module, filename) ->
			content = eco.compile fs.readFileSync filename, 'utf8'
			module._compile content, filename
catch err

try
	jade = require 'jade'
	compilers.jade = (module, filename) ->
		content = jade.compile ( fs.readFileSync filename, 'utf8' ), client:true
		runtime = "\n\nvar jade={}; (function(exports) {" + ( fs.readFileSync (require "path").resolve("#{__dirname}/../../jade/lib/runtime.js"), 'utf8' ) + "})(jade)"
		module._compile "#{runtime}; module.exports = #{content}", filename
catch err

try
	less = require 'less'
	compilers.less = (module, filename) ->
		content = fs.readFileSync filename, 'utf8'
		less.render content, (e, content) ->
			compilers.css module, filename, content
catch err

try 
	compilers.css = (module, filename, content = null) ->
		if content is null then content = fs.readFileSync filename, 'utf8'
		content = content.replace /\\/g, "\\\\"
		content = content.replace /\\?"/g, "\\\""
		content = content.replace /\r?\n/g, "\\n"
		name = filename.substr filename.lastIndexOf (if (process.platform.indexOf "win") is 0 then "\\" else "/")
		name = name.substr 1, name.indexOf(".") - 1
		module._compile "s = document.createElement('style'); s.innerHTML = \"#{content}\"; s.id = \"css-#{name}\"; document.head.appendChild(s);", filename
catch err

try
	compilers.json = (module, filename) ->
		content = fs.readFileSync filename, 'utf8'
		content = content.replace /\\?"/g, "\\\""
		content = content.replace /\r?\n/g, "\\n"
		name = filename.substr filename.lastIndexOf (if (process.platform.indexOf "win") is 0 then "\\" else "/")
		name = name.substr 1, name.indexOf(".") - 1
		module._compile """
			if (!window.JSONImport) window.JSONImport = {}; 
			var item = JSON.parse(\"#{content}\", function(key, value) { var v; try { v = eval(value) } catch(e) { v = value } return v;}); 
			return window.JSONImport['#{name}'] = module.exports = item;
		""", filename
catch error

try
	yaml = require "js-yaml"
	compilers.yaml = (module, filename) ->
		content = JSON.stringify yaml.load fs.readFileSync filename, 'utf8'
		content = content.replace /\\?"/g, "\\\""
		content = content.replace /\r?\n/g, "\\n"
		name = filename.substr filename.lastIndexOf (if (process.platform.indexOf "win") is 0 then "\\" else "/")
		name = name.substr 1, name.indexOf(".") - 1
		module._compile """
			if (!window.JSONImport) window.JSONImport = {}; 
			var item = JSON.parse(\"#{content}\", function(key, value) { var v; try { v = eval(value) } catch(e) { v = value } return v;}); 
			return window.JSONImport['#{name}'] = module.exports = item;
		""", filename
catch error

try
	mime = require "mime"
	compilers.eot = compilers.woff = compilers.ttf = compilers.otf = compilers.png = compilers.ico = compilers.gif = compilers.jpg = compilers.jpeg = (module, filename) ->
		content = fs.readFileSync(filename).toString "base64"
		name = filename.substr filename.lastIndexOf (if (process.platform.indexOf "win") is 0 then "\\" else "/")
		name = name.substr 1, name.indexOf(".") - 1
		module._compile """
			if (!window.imagePackage) window.imagePackage = function() { return \"data:\" + this.mime + \";base64,\" + this.content };
			if (!window.otherImports) window.otherImports = {}; 
			var item = {
				mime: '#{mime.lookup filename}', 
				content: '#{content}'
			};
			item.toString = function() { return window.imagePackage.apply(item, []); }
			return window.otherImports['#{name}'] = module.exports = item; 
		""", filename
catch error
 


exports.Package = class Package
	constructor: (config) ->
		@identifier	 = config.identifier ? 'require'
		@paths				= config.paths ? ['lib']
		@dependencies = config.dependencies ? []
		@keeps				= config.keeps ? []
		@compilers		= _.extend {}, compilers, config.compilers

		@cache				= config.cache ? true
		@mtimeCache	 = {}
		@compileCache = {}

	compile: (callback) ->
		async.parallel [
			@compileDependencies
			@compileSources
		], (err, parts) ->
			if err then callback err
			else callback null, parts.join("\n")

	compileDependencies: (callback) =>
		async.map @dependencies, @compileFile, (err, dependencySources) =>
			if err then callback err
			else callback null, dependencySources.join("\n")

	compileSources: (callback) =>
		async.reduce @paths, {}, _.bind(@gatherSourcesFromPath, @), (err, sources) =>
			return callback err if err

			result = """
				(function(/*! Stitch !*/) {
					if (!this.#{@identifier}) {
						var modules = {}, cache = {}, require = function(name, root) {
							var path = expand(root, name), module = cache[path], fn;
							if (module) {
								return module.exports;
							} else if (fn = modules[path] || modules[path = expand(path, './index')]) {
								module = {id: path, exports: {}};
								try {
									cache[path] = module;
									fn(module.exports, function(name) {
										return require(name, dirname(path));
									}, module);
									return module.exports;
								} catch (err) {
									delete cache[path];
									throw err;
								}
							} else {
								throw 'module \\'' + name + '\\' not found';
							}
						}, expand = function(root, name) {
							var results = [], parts, part;
							if (/^\\.\\.?(\\/|$)/.test(name)) {
								parts = [root, name].join('/').split('/');
							} else {
								parts = name.split('/');
							}
							for (var i = 0, length = parts.length; i < length; i++) {
								part = parts[i];
								if (part == '..') {
									results.pop();
								} else if (part != '.' && part != '') {
									results.push(part);
								}
							}
							return results.join('/');
						}, dirname = function(path) {
							return path.split('/').slice(0, -1).join('/');
						};
						this.#{@identifier} = function(name) {
							return require(name, '');
						}
						this.#{@identifier}.define = function(bundle) {
							for (var key in bundle)
								modules[key] = bundle[key];
						};
					}
					return this.#{@identifier}.define;
				}).call(this)({
			"""

			index = 0
			for name, {filename, source} of sources
				name = name.replace /[\\\\]/g, "/"
				result += if index++ is 0 then "" else ", "
				result += JSON.stringify name
				result += ": function(exports, require, module) {#{source}}"

			result += """
				});\n
			"""

			callback err, result

	createServer: ->
		(req, res, next) =>
			@compile (err, source) ->
				if err
					console.error "#{err.stack}"
					message = "" + err.stack
					res.writeHead 500, 'Content-Type': 'text/javascript'
					res.end "throw #{JSON.stringify(message)}"
				else
					res.writeHead 200, 'Content-Type': 'text/javascript'
					res.end source


	gatherSourcesFromPath: (sources, sourcePath, callback) ->
		fs.stat sourcePath, (err, stat) =>
			return callback err if err

			if stat.isDirectory()
				@getFilesInTree sourcePath, (err, paths) =>
					return callback err if err
					async.reduce paths, sources, _.bind(@gatherCompilableSource, @), callback
			else
				@gatherCompilableSource sources, sourcePath, callback

	gatherCompilableSource: (sources, path, callback) ->
		if @compilers[extname(path).slice(1)]
			@getRelativePath path, (err, relativePath) =>
				return callback err if err

				@compileFile path, (err, source) ->
					if err then callback err
					else
						extension = extname relativePath
						key			 = relativePath.slice(0, -extension.length)
						sources[key] =
							filename: relativePath
							source:	 source
						callback err, sources
		else
			callback null, sources

	getRelativePath: (path, callback) ->
		fs.realpath path, (err, sourcePath) =>
			return callback err if err
			keeps = @keeps
			async.map @paths, fs.realpath, (err, expandedPaths) ->
				return callback err if err

				for expandedPath in expandedPaths
					base = expandedPath + ( if (process.platform.indexOf("win") is 0) then "\\" else "/")

					if sourcePath.indexOf(base) is 0
						add = false
						for keep in keeps
							if (sourcePath.match keep.match)? then add = sourcePath.match keep.keep					 
						if add
							pre = base.slice 0, base.indexOf add[0]
							post = base.slice (base.indexOf add[0]) + add[0].length
							sp = sourcePath.slice (sourcePath.indexOf pre) + pre.length
							add = sourcePath.slice (sourcePath.indexOf post) + post.length
							sp = sp.slice 0, sp.indexOf post
							sp = sp + add
						else sp = sourcePath.replace base, ""
						return callback null, sp
				callback new Error "#{path} isn't in the require path"

	compileFile: (path, callback) =>
		extension = extname(path).slice(1)

		if @cache and @compileCache[path] and @mtimeCache[path] is @compileCache[path].mtime
			callback null, @compileCache[path].source
		else if compile = @compilers[extension]
			source = null
			mod =
				_compile: (content, filename) ->
					source = content

			try
				compile mod, path

				if @cache and mtime = @mtimeCache[path]
					@compileCache[path] = {mtime, source}

				callback null, source
			catch err
				if err instanceof Error
					err.message = "can't compile #{path}\n#{err.message}"
				else
					err = new Error "can't compile #{path}\n#{err}"
				callback err
		else
			callback new Error "no compiler for '.#{extension}' files"

	walkTree: (directory, callback) ->
		fs.readdir directory, (err, files) =>
			return callback err if err

			async.forEach files, (file, next) =>
				return next() if file.match /^\./
				filename = join directory, file

				fs.stat filename, (err, stats) =>
					@mtimeCache[filename] = stats?.mtime?.toString()

					if !err and stats.isDirectory()
						@walkTree filename, (err, filename) ->
							if filename
								callback err, filename
							else
								next()
					else
						callback err, filename
						next()
			, callback

	getFilesInTree: (directory, callback) ->
		files = []
		@walkTree directory, (err, filename) ->
			if err
				callback err
			else if filename
				files.push filename
			else
				callback err, files.sort()


exports.createPackage = (config) ->
	new Package config
